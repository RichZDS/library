# BTreeBook 类函数详解

`BTreeBook` 类使用 B 树结构，以书号（`book.id`）作为键来存储和管理图书信息。

## 节点结构

```cpp
struct BTreeBookNode {
    bool leaf;                          // 是否为叶子节点
    vector<string> keys;                // 书号列表（有序）
    vector<Book> records;               // 对应的图书记录
    vector<BTreeBookNode*> children;    // 子节点指针列表
};
```

## 构造函数和析构函数

### `BTreeBook(int t = 2)`

**功能**：创建 B 树对象

**参数**：
- `t`：最小度数（degree），默认为 2（即 2-3 树）

**说明**：
- 初始化根节点为 `nullptr`（空树）
- 最小度数决定了每个节点键的数量范围

**示例**：
```cpp
BTreeBook books;  // 创建 2-3 树（默认）
```

---

### `~BTreeBook()`

**功能**：析构函数，释放整个 B 树的内存

**说明**：
- 调用 `destroy(root)` 递归释放所有节点
- 使用后序遍历确保先释放子节点再释放父节点

---

## 搜索操作

### `Book* search(const string& id) const`

**功能**：在 B 树中搜索指定书号的图书

**参数**：
- `id`：要查找的书号

**返回值**：
- 找到：返回指向 `Book` 对象的指针
- 未找到：返回 `nullptr`

**时间复杂度**：O(log n)

**算法流程**：
1. 从根节点开始
2. 在当前节点中找到第一个大于等于 `id` 的键的位置
3. 如果找到完全匹配的键，返回对应的记录
4. 如果是叶子节点且未找到，返回 `nullptr`
5. 否则递归搜索相应的子节点

**示例**：
```cpp
Book* book = books.search("B001");
if (book) {
    cout << "找到图书：" << book->title << endl;
}
```

---

### `Book* searchNode(BTreeBookNode* x, const string& id) const`

**功能**：在指定节点及其子树中递归搜索

**参数**：
- `x`：当前搜索的节点
- `id`：要查找的书号

**返回值**：找到返回 `Book*`，否则返回 `nullptr`

**说明**：这是 `search()` 的递归实现，是核心搜索算法

---

## 插入操作

### `void insert(const Book& book)`

**功能**：向 B 树中插入一本新书

**参数**：
- `book`：要插入的图书对象

**时间复杂度**：O(log n)

**算法流程**：
1. 如果树为空，创建根节点并插入
2. 如果根节点已满（有 `2*t-1` 个键）：
   - 创建新的根节点
   - 将原根节点作为新根的子节点
   - 分裂原根节点（这是 B 树**唯一**会增加树高度的操作）
3. 调用 `insertNonFull()` 在非满节点中插入

**示例**：
```cpp
Book newBook;
newBook.id = "B004";
newBook.title = "计算机网络";
// ... 设置其他属性
books.insert(newBook);
```

---

### `void insertNonFull(BTreeBookNode* x, const Book& book)`

**功能**：在非满节点中插入新记录（递归函数）

**参数**：
- `x`：当前节点（保证不满）
- `book`：要插入的图书

**算法流程**：
1. **情况 1：叶子节点**
   - 找到正确的插入位置
   - 从右向左移动所有大于 `book.id` 的键
   - 在正确位置插入新键和记录

2. **情况 2：内部节点**
   - 找到应该插入的子节点索引 `i`
   - 如果子节点已满，先调用 `splitChild()` 分裂它
   - 分裂后需要判断新键应该插入左子节点还是右子节点
   - 递归调用 `insertNonFull()` 插入到子节点

**说明**：这是 B 树插入的核心递归函数，保证在插入过程中，目标节点始终不满

---

### `void splitChild(BTreeBookNode* x, int i)`

**功能**：分裂已满的子节点（B 树保持平衡的关键操作）

**参数**：
- `x`：父节点
- `i`：要分裂的子节点在 `x->children` 中的索引

**操作流程**：
1. 获取已满的子节点 `y = x->children[i]`
2. 创建新节点 `z` 存放 `y` 的后半部分
3. 将 `y` 的后 `t-1` 个键和记录移动到 `z`
4. 如果 `y` 不是叶子节点，将后 `t` 个子节点也移动到 `z`
5. 将 `y` 的中间键（第 `t-1` 个）提升到父节点 `x` 的位置 `i`
6. 将新节点 `z` 插入到 `x->children` 的位置 `i+1`
7. 收缩 `y` 节点，只保留前 `t-1` 个键和 `t` 个子节点

**图示**（t=2，分裂前 y 有 3 个键）：
```
分裂前：
x: [key1]
    |
    y: [k1, k2, k3]  ← 已满

分裂后：
x: [key1, k2]  ← k2 被提升
    |    |
    y    z
[k1]   [k3]   ← y 和 z 各保留 1 个键
```

**说明**：分裂操作确保了 B 树的结构性质始终满足

---

## 删除操作

### `bool remove(const string& id)`

**功能**：从 B 树中删除指定书号的图书

**参数**：
- `id`：要删除的书号

**返回值**：
- 成功删除返回 `true`
- 未找到返回 `false`

**时间复杂度**：O(n)（因为使用了重建法）

**算法说明**：
本项目使用的是**简化实现（重建法）**，而不是标准的 B 树删除算法：

1. 中序遍历收集所有图书数据
2. 从数据中删除目标图书
3. 销毁原树
4. 重建整个 B 树（重新插入所有数据）

**优点**：实现简单，易于理解

**缺点**：效率较低，但对于学习目的足够

**示例**：
```cpp
if (books.remove("B001")) {
    cout << "删除成功！" << endl;
}
```

**注意**：标准的 B 树删除算法更复杂，需要处理多种情况（叶子节点删除、内部节点删除、合并节点等），但时间复杂度是 O(log n)

---

## 遍历操作

### `void inorder(vector<Book>& out) const`

**功能**：中序遍历 B 树，按书号顺序收集所有图书

**参数**：
- `out`：输出向量，用于存储遍历结果

**时间复杂度**：O(n)

**说明**：中序遍历保证了结果按书号的字典序排列

**示例**：
```cpp
vector<Book> allBooks;
books.inorder(allBooks);
for (const auto& book : allBooks) {
    cout << book.id << ": " << book.title << endl;
}
```

---

### `void inorderNode(BTreeBookNode* x, vector<Book>& out) const`

**功能**：递归实现中序遍历

**算法**：
1. 对于节点中的每个键 `keys[i]`：
   - 如果不是叶子节点，先递归遍历 `children[i]`（左子树）
   - 访问当前键对应的记录 `records[i]`
2. 如果不是叶子节点，最后递归遍历 `children.back()`（右子树）

**说明**：这是 B 树中序遍历的核心递归函数

---

## 树结构可视化

### `string getStructure() const`

**功能**：获取 B 树的凹入表（Indented Table）表示

**返回值**：字符串形式的树结构

**说明**：凹入表通过缩进层级表示树的父子关系，便于可视化 B 树结构
 
**示例输出**：
```
[ B001 B002 ]
    [ B001 ] (leaf)
    [ B002 B003 ] (leaf)
```

---

### `void getStructureNode(BTreeBookNode* x, int depth, stringstream& ss) const`

**功能**：递归生成凹入表字符串

**参数**：
- `x`：当前节点
- `depth`：当前深度（用于控制缩进）
- `ss`：字符串流，用于拼接结果

---

## 辅助函数

### `void destroy(BTreeBookNode* x)`

**功能**：递归销毁 B 树节点及其所有子节点

**参数**：
- `x`：要销毁的节点

**说明**：使用后序遍历，先销毁所有子节点，再销毁当前节点